[gd_scene load_steps=15 format=3 uid="uid://b5swpafe0e65g"]

[ext_resource type="Script" uid="uid://dp3ttq14t6880" path="res://dimension/earth/daynight.gd" id="1_13d63"]
[ext_resource type="PackedScene" uid="uid://cpnrooe0coq4o" path="res://core/player/player.res" id="1_p8oot"]
[ext_resource type="Texture2DArray" path="res://core/ground_materials/aa.tres" id="2_vdwhi"]

[sub_resource type="ProceduralSkyMaterial" id="ProceduralSkyMaterial_q8shm"]
sky_horizon_color = Color(0.66224277, 0.6717428, 0.6867428, 1)
ground_horizon_color = Color(0.66224277, 0.6717428, 0.6867428, 1)

[sub_resource type="Sky" id="Sky_l7kbd"]
sky_material = SubResource("ProceduralSkyMaterial_q8shm")

[sub_resource type="Environment" id="Environment_8xcb0"]
background_mode = 2
sky = SubResource("Sky_l7kbd")
tonemap_mode = 2
ssr_enabled = true
ssr_max_steps = 272
sdfgi_enabled = true
sdfgi_cascades = 8
sdfgi_min_cell_size = 0.07930908
sdfgi_y_scale = 2
glow_enabled = true

[sub_resource type="VoxelStreamMemory" id="VoxelStreamMemory_13d63"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_3p8ni"]

[sub_resource type="VoxelGeneratorNoise2D" id="VoxelGeneratorNoise2D_vdwhi"]
noise = SubResource("FastNoiseLite_3p8ni")

[sub_resource type="VoxelMesherTransvoxel" id="VoxelMesherTransvoxel_13d63"]
texturing_mode = 1

[sub_resource type="VoxelFormat" id="VoxelFormat_qmu6g"]

[sub_resource type="Shader" id="Shader_3p8ni"]
code = "shader_type spatial;

// Textures should preferably be in a Texture2DArray, so looking them up is cheap
uniform sampler2DArray u_texture_array : source_color;

// We'll need to pass data from the vertex shader to the fragment shader
varying vec4 v_indices;
varying vec4 v_weights;
varying vec3 v_normal;
varying vec3 v_pos;

// We'll use a utility function to decode components.
// It returns 4 values in the range [0..255].
vec4 decode_8bit_vec4(float v) {
    uint i = floatBitsToUint(v);
    return vec4(
        float(i & uint(0xff)),
        float((i >> uint(8)) & uint(0xff)),
        float((i >> uint(16)) & uint(0xff)),
        float((i >> uint(24)) & uint(0xff)));
}

// A voxel mesh can have overhangs in any direction,
// so we may have to use triplanar mapping functions.
vec3 get_triplanar_blend(vec3 world_normal) {
    vec3 blending = abs(world_normal);
    blending = normalize(max(blending, vec3(0.00001))); // Force weights to sum to 1.0
    float b = blending.x + blending.y + blending.z;
    return blending / vec3(b, b, b);
}

vec4 texture_array_triplanar(sampler2DArray tex, vec3 world_pos, vec3 blend, float i) {
    vec4 xaxis = texture(tex, vec3(world_pos.yz, i));
    vec4 yaxis = texture(tex, vec3(world_pos.xz, i));
    vec4 zaxis = texture(tex, vec3(world_pos.xy, i));
    // blend the results of the 3 planar projections.
    return xaxis * blend.x + yaxis * blend.y + zaxis * blend.z;
}

void vertex() {
    // Indices are integer values so we can decode them as-is
    v_indices = decode_8bit_vec4(CUSTOM1.x);

    // Weights must be in [0..1] so we divide them
    v_weights = decode_8bit_vec4(CUSTOM1.y) / 255.0;

    v_pos = VERTEX;
    v_normal = NORMAL;

    //...
}

void fragment() {
    // Define a texture scale for convenience.
    // We can use an array instead if different scales per index is needed.
    float uv_scale = 0.5;

    // Sample the 4 blending textures, all with triplanar mapping.
    // We can re-use the same triplanar blending factors for all of them so separating that part
    // of the function improves performance a little.
    vec3 blending = get_triplanar_blend(v_normal);
    vec3 col0 = texture_array_triplanar(u_texture_array, v_pos * uv_scale, blending, v_indices.x).rgb;
    vec3 col1 = texture_array_triplanar(u_texture_array, v_pos * uv_scale, blending, v_indices.y).rgb;
    vec3 col2 = texture_array_triplanar(u_texture_array, v_pos * uv_scale, blending, v_indices.z).rgb;
    vec3 col3 = texture_array_triplanar(u_texture_array, v_pos * uv_scale, blending, v_indices.w).rgb;

    // Get weights and make sure they are normalized.
    // We may add a tiny safety margin so we can afford some degree of error.
    vec4 weights = v_weights;
    weights /= (weights.x + weights.y + weights.z + weights.w + 0.00001);

    // Calculate albedo
    vec3 col = 
        col0 * weights.r + 
        col1 * weights.g + 
        col2 * weights.b + 
        col3 * weights.a;

    ALBEDO = col;

    //...
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_vdwhi"]
render_priority = 0
shader = SubResource("Shader_3p8ni")
shader_parameter/u_texture_array = ExtResource("2_vdwhi")

[sub_resource type="BoxMesh" id="BoxMesh_vdwhi"]

[node name="earth" type="Node3D"]

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_8xcb0")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 0.9921147, 0.12533323, 0, -0.12533323, 0.9921147, 0, 0, 0)
light_energy = 0.525
shadow_enabled = true
script = ExtResource("1_13d63")

[node name="VoxelLodTerrain" type="VoxelLodTerrain" parent="."]
stream = SubResource("VoxelStreamMemory_13d63")
generator = SubResource("VoxelGeneratorNoise2D_vdwhi")
mesher = SubResource("VoxelMesherTransvoxel_13d63")
format = SubResource("VoxelFormat_qmu6g")
view_distance = 1622
material = SubResource("ShaderMaterial_vdwhi")
run_stream_in_editor = false

[node name="Player" parent="." groups=["player"] instance=ExtResource("1_p8oot")]
transform = Transform3D(2, 0, 0, 0, 2, 0, 0, 0, 2, 56.96766, 569.4879, -0.039052725)

[node name="CSGMesh3D" type="CSGMesh3D" parent="."]
transform = Transform3D(9.6, 0, 0, 0, 1, 0, 0, 0, 14.7, 56, 95, 0)
use_collision = true
mesh = SubResource("BoxMesh_vdwhi")
